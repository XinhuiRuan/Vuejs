<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>列表渲染，搜索和排序</title>
    <script src="../vue.js"></script>
   
</head>
<body>
   
    <div id="app">
    <!--
       列表渲染
    -->
       <h2>测试：v-for 遍历数组</h2>
        <ul>
            <li v-for="(p,index) in persons" :key="index">
                {{index}} ----- {{p.name}} ----- {{p.age}}
                ----- <button @click='deleteP(index)'>删除</button>
                ----- <button @click="updateP(index,{name:'Cat',age:'20'})">更新</button>
            </li>
        </ul>

       <h2>测试：v-for 遍历对象</h2>
         <ul>    
            <li v-for="(value,key) in persons[1]" :key="key">
                {{key}} ----- {{value}} 
            </li>
         </ul>

    <!--
       1. 列表过滤
       2. 列表排序
   -->
        <input type="text" v-model="keyName">
        <ul>
                <li v-for="(p,index) in filterPersons" :key="index">
                    {{index}} ----- {{p.name}} ----- {{p.age}}
                </li>
        </ul>
        <button @click="setOrderType(1)">年龄升序</button>
        <button @click="setOrderType(2)">年龄降序</button>
        <button @click="setOrderType(0)">原本顺序</button>
    </div>
    
 <script>
     // vue本身只是监视了persons的改变，没有监视数组内部数据的改变
     // vue重写了数组中的一系列改变数组内部数据的方法(先调用原生，再重写更新界面)
     var vm = new Vue({
        el:"#app",
        data:{
            persons:[
                {name:'Tom',age:'18'},
                {name:'Jack',age:'16'},
                {name:'Bob',age:'19'},
                {name:'Rose',age:'17'},
            ],
            keyName:"",
            // filterPersons:[  // 搭配watch方法
            //     {name:'Tom',age:'18'},
            //     {name:'Jack',age:'16'},
            //     {name:'Bob',age:'19'},
            //     {name:'Rose',age:'17'},
            // ],
            orderType: 0 // 0代表原本排序，1代表升序，2代表降序
        },
        methods:{
            deleteP(index){
                this.persons.splice(index,1);
            },
            updateP(index,obj){
                // 不能实现的原因：数组内部发生了变化，但并没有调用变异方法，vue不会更新界面
                //this.persons[index] = obj;  
                this.persons.splice(index,1,obj);  //利用splice方法实现数组的替换（还可以实现删除和添加）
                //this.persons[index].name = obj.name;
                //this.persons[index].age = obj.age;
            },   
            setOrderType(setValue){
                this.orderType = setValue;
            } 
         },
         computed:{  // 老师的办法
            filterPersons(){
                // ES6知识点：取出相关数据
                //const {keyName,persons,orderType} = this;
                // 相当于
                // const keyName = this.keyName;
                // const persons = this.persons;
                // const orderType = this.orderType;

                // 对persons进行过滤
                var fPersons = this.persons.filter(p => p.name.indexOf(this.keyName) != -1);

                // 排序
                var orderType = this.orderType;
                if(orderType !== 0){
                    fPersons.sort(function(p1,p2){ // 如果返回负数，p1在前；正数，p2在前
                        // 1代表升序，2代表降序
                        if(orderType === 2){  //在这个方法里不能用this.orderType
                            return p2.age - p1.age;
                         }else{
                             return p1.age - p2.age;
                         }
                    })
                }
                return fPersons;
            }
         },
        // watch:{  // 自己使用watch实现了列表过滤
        //     keyName:function(newValue){
               
        //         this.filterPersons = this.persons.filter(p => p.name.indexOf(newValue) != -1);
        //     }
       //}
     });

</script>   
</body>
</html>